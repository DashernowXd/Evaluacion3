<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Waves y musica</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body>

		<script type="x-shader/x-vertex" id="vertexshader">

			attribute float scale;

			void main() {

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = scale * ( 300.0 / - mvPosition.z );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;

			void main() {

				if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;

				gl_FragColor = vec4( color, 1.0 );

			}

		</script>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script type="importmap">
 			 {
  		 		 "imports": {
     		 	 "three": "https://unpkg.com/three@<version>/build/three.module.js",
     			 "es-module-shims": "https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
   					 }	
 			 }
	</script>

<!-- Download the files and reference them locally: -->
	<script type="importmap">
		  {
  			  "imports": {
  		      "three": "./lib/three.module.js",
      		  "es-module-shims": "./lib/es-module-shims.js"
              }
          }
	</script>



		
		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			const SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;

			let container, stats;
			let camera, scene, renderer;

			let particles, count = 0;

			let mouseX = 0, mouseY = 0;

			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;
			
			//Variables para el audio
			var context;
    		var sourceNode;
    		var analyser;
    		var analyser2;


			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.x = 1200;
				camera.position.z = 4000;
				camera.position.y = 1200;
				//camera.lookAt(scene.position);
				

				scene = new THREE.Scene();

				const numParticles = AMOUNTX * AMOUNTY;

				const positions = new Float32Array( numParticles * 3 );
				const scales = new Float32Array( numParticles );

				let i = 0, j = 0;

				for ( let ix = 0; ix < AMOUNTX; ix ++ ) {

					for ( let iy = 0; iy < AMOUNTY; iy ++ ) {

						positions[ i ] = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 ); // x
						positions[ i + 1 ] = 0; // y
						positions[ i + 2 ] = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 ); // z

						scales[ j ] = 1;

						i += 3;
						j ++;

					}

				}

				const geometry = new THREE.BufferGeometry();
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'scale', new THREE.BufferAttribute( scales, 1 ) );

				const material = new THREE.ShaderMaterial( {

					uniforms: {
						color: { value: new THREE.Color( 0xC9FC0B ) },
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent

				} );


				particles = new THREE.Points( geometry, material );
				particles.name = 'particles';
				scene.add( particles );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );


				//

				window.addEventListener( 'resize', onWindowResize );
				
				setupSound();
				render();

				loadSound("ugu.ogg");
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				var rotSpeed = 0.001;
   	 			camera.position.x = camera.position.x * Math.cos(rotSpeed) + camera.position.z * Math.sin(rotSpeed);
    			camera.position.z = camera.position.z * Math.cos(rotSpeed) - camera.position.x * Math.sin(rotSpeed);
				camera.lookAt( scene.position );

				const positions = particles.geometry.attributes.position.array;
				const scales = particles.geometry.attributes.scale.array;

				let i = 0, j = 0;

				for ( let ix = 0; ix < AMOUNTX; ix ++ ) {

					for ( let iy = 0; iy < AMOUNTY; iy ++ ) {

						positions[ i + 1 ] = ( Math.sin( ( ix + count ) * 0.3 ) * 50 ) + ( Math.sin( ( iy + count ) * 0.5 ) * 50 );

						scales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 20 + ( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 20;

						i += 3;
						j ++;
					}

				}

				particles.geometry.attributes.position.needsUpdate = true;
				particles.geometry.attributes.scale.needsUpdate = true;

				renderer.render( scene, camera );

				updateCubes();
				
				count += 0.1;

				//requestAnimationFrame(render);
			}


			function updateCubes() {
        		// get the average for the first channel
        		var array =  new Uint8Array(analyser.frequencyBinCount);
        		analyser.getByteFrequencyData(array);
        		var average = getAverageVolume(array);
				

        		// clear the current state
        		if (scene.getObjectByName('particles')) {
        		var ps = scene.getObjectByName('particles');
        		//ps.scale.x = average / 20;
        		//ps.scale.z = average / 20;
				ps.scale.y = average / 20;
				}
    		}	



			//Funciones para cargar el audio
			function setupSound() {
        		if (! window.AudioContext) {
            		if (! window.webkitAudioContext) {
                		alert('no audiocontext found');
            		}
            		window.AudioContext = window.webkitAudioContext;
        		}
        		context = new AudioContext();

        		// setup a analyzer
        		analyser = context.createAnalyser();
        		analyser.smoothingTimeConstant = 0.4;
        		analyser.fftSize = 1024;

        		analyser2 = context.createAnalyser();
        		analyser2.smoothingTimeConstant = 0.4;
        		analyser2.fftSize = 1024;

        		// create a buffer source node
        		sourceNode = context.createBufferSource();
        		var splitter = context.createChannelSplitter();

        		// connect the source to the analyser and the splitter
        		sourceNode.connect(splitter);

        		// connect one of the outputs from the splitter to
        		// the analyser
        		splitter.connect(analyser,0);
        		splitter.connect(analyser2,1);

        		// and connect to destination
        		sourceNode.connect(context.destination);

        		context = new AudioContext();
			}


    		function getAverageVolume(array) {
        		var values = 0;
        		var average;

        		var length = array.length;

        		// get all the frequency amplitudes
        		for (var i = 0; i < length; i++) {
            	values += array[i];
        		}

        		average = values / length;
        		return average;
    		}

    		function playSound(buffer) {
        		sourceNode.buffer = buffer;
        		sourceNode.start(0);
    		}

    		// load the specified sound
    		function loadSound(url) {
        		var request = new XMLHttpRequest();
        		request.open('GET', url, true);
        		request.responseType = 'arraybuffer';

        		// When loaded decode the data
        		request.onload = function() {

            		// decode the data
            		context.decodeAudioData(request.response, function(buffer) {
                		// when the audio is decoded play the sound
                		playSound(buffer);
            		}, onError);
        		}
        		request.send();
    		}

    		function onError(e) {
        		console.log(e);
    		}


		</script>
	</body>
</html>







<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - particles - waves</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
	</head>
	<body>

		<div id="info">
			

		<script type="x-shader/x-vertex" id="vertexshader">

			attribute float scale;

			void main() {

				vec4 mvPosition = modelViewMatrix * vec4( position, 2.0 );

				gl_PointSize = scale * ( 300.0 / - mvPosition.z );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>
		<script src="../libs/chroma.min.js"></script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;

			void main() {

				if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;

				gl_FragColor = vec4( color, 1.0 );

			}

		</script>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		
		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';
			

			const SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;

			let container, stats;
			let camera, scene, renderer;

			let particles, count = 0;

			let mouseX = 0, mouseY = 0;

			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;

			
			var context;
			var sourceNode;
			var analyser;
			var analyser2;
			var oscilator;
			var source2;
			var javascriptNode;

			init();
			animate();
			

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;

				scene = new THREE.Scene();

				//

				const numParticles = AMOUNTX * AMOUNTY;

				const positions = new Float32Array( numParticles * 3 );
				const scales = new Float32Array( numParticles );

				let i = 0, j = 0;

				for ( let ix = 0; ix < AMOUNTX; ix ++ ) {

					for ( let iy = 0; iy < AMOUNTY; iy ++ ) {

						positions[ i ] = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 ); // x
						positions[ i + 1 ] = 0; // y
						positions[ i + 2 ] = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 ); // z

						scales[ j ] = 1;

						i += 3;
						j ++;

					}

				}

				const geometry = new THREE.BufferGeometry();
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'scale', new THREE.BufferAttribute( scales, 1 ) );

				const material = new THREE.ShaderMaterial( {

					uniforms: {
						color: { value: new THREE.Color('white') },
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent

				} );

				//

				particles = new THREE.Points( geometry, material );
				scene.add( particles );

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				container.style.touchAction = 'none';
				container.addEventListener( 'pointermove', onPointerMove );
				
				
				setupSound();
				
			loadSound("ugu.ogg");
			render ();
				
				window.addEventListener( 'resize', onWindowResize );


		
			

			
				

			}

			function setupSound() {
                    if (! window.AudioContext) {
                        if (! window.webkitAudioContext) {
                            alert('no audiocontext found');
                        }
                        window.AudioContext = window.webkitAudioContext;
                    }
                    context = new AudioContext();
					

                    // setup a analyzer
                    analyser = context.createAnalyser();
                    analyser.smoothingTimeConstant = 0.4;
                    analyser.fftSize = 1024;

                    analyser2 = context.createAnalyser();
                    analyser2.smoothingTimeConstant = 0.4;
                    analyser2.fftSize = 1024;
					


                    // create a buffer source node
                    sourceNode = context.createBufferSource();
                    var splitter = context.createChannelSplitter();

                    // connect the source to the analyser and the splitter
                    sourceNode.connect(splitter);

                    // connect one of the outputs from the splitter to
                    // the analyser
                    splitter.connect(analyser,0,0);
                    splitter.connect(analyser2,0 , 0);
					
                    // and connect to destination
                    sourceNode.connect(context.destination);
					
					

					
					
					

                    context = new AudioContext();
                }
                
                function playSound(buffer) {
                        sourceNode.buffer = buffer;
                        sourceNode.start(0);
                }

                    // load the specified sound
                function loadSound(url) {
                        var request = new XMLHttpRequest();
                        request.open('GET', url, true);
                        request.responseType = 'arraybuffer';

                        // When loaded decode the data
                        request.onload = function() {

                            // decode the data
                            context.decodeAudioData(request.response, function(buffer) {
                                // when the audio is decoded play the sound
                                playSound(buffer);
                            }, onError);
                        }
                        request.send();
                }

                function onError(e) {
                    console.log(e);
                }

				


		

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();
				
			}
			
			
			
			
			

			function render() {

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );
				renderer.render( scene, camera );
					updateWaves();
			}
				function updateWaves(){
					var array= new Uint8Array(analyser.frequencyBinCount);
					analyser.getByteTimeDomainData(array);
						const scale= chroma.scale(['white', 'blue', 'red']).domain([0,20]);
						var average;
						var values=0;
						const scales = particles.geometry.attributes.scale.array;
						const position= particles.geometry.attributes.position.array;
						let i = 0, j = 0, z=0;
						for ( let ix = 0; ix < AMOUNTX; ix ++ ) {
							

for ( let iy = 0; iy < AMOUNTY; iy ++ ) {

								scales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 20 +
										( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 20;
								position[i]=Math.abs(array[ix]-array[iy])*10;
								particles.geometry.scale.y=average;
								values+=array[i]
								i += 3;
								j ++;
								z++;
								average=values/20;
	

}

}
						


				particles.geometry.attributes.scale.needsUpdate = true;
				particles.geometry.attributes.position.needsUpdate = true;
				count += 0.1;
			}

			
			

			

		</script>
	</body>
</html>









